// Big O Analysis
// 2021 Christopher Digno
#include "../include/pch.h"
using namespace std;

#define INITRD(low, high) random_device randev;                                 \
                          mt19937 gen(randev());                                \
                          uniform_int_distribution<int> dist((low), (high))     \

class Timer {
private:
    chrono::time_point<chrono::high_resolution_clock> m_startTime;
    chrono::time_point<chrono::high_resolution_clock> m_endTime;
    long long ms;
    long long us;
public:
    Timer(bool immidiatelyStart) {
        us = 0LL;
        ms = 0LL;
        if (immidiatelyStart == true) {
            start();
        }
    }

    void start() {
        m_startTime = chrono::high_resolution_clock::now();
    }

    void stop() {
        m_endTime = chrono::high_resolution_clock::now();

        auto alpha = chrono::time_point_cast<chrono::microseconds>(m_startTime).time_since_epoch().count();
        auto omega = chrono::time_point_cast<chrono::microseconds>(m_endTime).time_since_epoch().count();
        auto duration = omega - alpha;
        ms = duration / 1000LL;
        us = duration;
    }

    long long getms() {
        return ms;
    }

    long long getus() {
        return us;
    }

    ~Timer() {
        stop();
    }
};

void _debugTestPrint(Timer &obj) {
    cout << "Time: " << obj.getms() << " ms (" << obj.getus() << " us)\n";
}

void initTimeHandler(string &name) {
    stringstream strs;
    auto now = time(0);
    tm *stm = localtime(&now);
    //testmsg_DDMMYYYY_HH:MM:SS.csv
    strs << "res//testmsg_";
    strs << setfill('0') << setw(2) << stm->tm_mday << flush;
    strs << setfill('0') << setw(2) << 1 + stm->tm_mon << flush;
    strs << 1900 + stm->tm_year << "_";
    strs << setfill('0') << setw(2) << stm->tm_hour << flush;
    strs << setfill('0') << setw(2) << stm->tm_min << flush;
    strs << setfill('0') << setw(2) << stm->tm_sec << flush;
    strs << ".csv";
    name = strs.str();
}

template <typename Ft>
void testWithFunctor(Ft func, string case_name, ofstream &file, vector<vector<int>> &thiscase, 
                     int num_case = 20, int multiplier = 500) {
    int *arr = nullptr;
    for (int i = 1; i <= num_case; i++) {
        Timer test(true);
        arr = thiscase[i - 1].data();
        func(arr, (i * multiplier));
        test.stop();
        cout << "Length: " << i * multiplier << ": ";
        file << case_name << ',' << i * multiplier << "," << test.getus() << '\n';
        _debugTestPrint(test);
    }
}

int main() {
    string filename("");
    initTimeHandler(filename);
    ofstream file(filename);
    file << "alg#,n,time(us)" << '\n';

    // Generating 2 arrays for 1st and 2nd Algorithm's random case
    // -> Ever since those 2 algorithms basically will be fed
    //    with the same data, we can also find out which is more effective

    cout << "Generating testcases...\n";
    vector<vector <int>> rdcase1, rdcase2;
    vector<int> vecbuf1;
    INITRD(0, 9999);
    for (int i = 500; i < 10001; i += 500) {
        for (int j = 0; j < i; j++) {
            vecbuf1.push_back(dist(gen));
        }
        rdcase1.push_back(vecbuf1);
        vecbuf1.clear();
    }
    rdcase2 = rdcase1;
    cout << "Generating done.\n";

    {   // >>> Testrunning 1st Algorithm <<<
        // 1. Testing to the algorithm, noting the time spent. Steps -> convert vector data to int*, and then
        //    pass it to the algorithm.
        
        cout << "=== 1st Algorithm ===\n";
        testWithFunctor(STAY, "1", file, rdcase1);
        cout << "Algorithm 1's test done, result's exported.\n";
    }

    {   // >>> Testrunning 2nd Algorithm <<<
        // Part 1: Random Case for Big O
        // 1. Testing, same as algorithm 1

        cout << "=== 2nd Algorithm ===\n = Random Case =";
        testWithFunctor(HOME, "2random", file, rdcase2);
        cout << "Algorithm 2's test done, result's exported.\n";

        // Part 2: Best Case and Worst Case
        // 1. Generating case, will be generated using sequential data, with increasing length
        //    from 500 - 1000 array length for better understanding.
        // 2. Best Case's data will be sorted already, and the worst case is reverse-sorted,
        //    generated by using STL algorithm "reverse" on sorted data.
   
        cout << "Generating Best Case and Worst Case for 2nd Algorithm...\n";
        vector<vector<int>> btcase2;
        vector<int> vecbuf;
        for (int i = 500; i < 10001; i += 500) {
            for (int j = 0; j < i; j++) {
                vecbuf.push_back(j);
            }
            btcase2.push_back(vecbuf);
            vecbuf.clear();
        }

        vector<vector<int>> wscase2 = btcase2;
        for (int i = 0; i < wscase2.size(); i++) {
            reverse(wscase2[i].begin(), wscase2[i].end());
        }
        cout << "Generating done.\n";

        // 3. Running the test.
        cout << "= Best Case =\n";
        testWithFunctor(HOME, "2best", file, btcase2);
        cout << "Best case test done\n= Worst Case =\n";
        testWithFunctor(HOME, "2worst", file, wscase2);
        cout << "Worst case done. 2nd Algorithm testing done.\n";
    }

    {   // >>> Testrunning 3rd Algorithm <<<

    }

    file.close();
}